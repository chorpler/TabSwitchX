/* * Copyright (c) 2021 by Fuhrer Engineering AG, CH-2504 Biel/Bienne, Switzerland & Bas Leijdekkers * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.intellij.ideaplugins.tabswitchx;import com.intellij.execution.filters.TextConsoleBuilderFactory;import com.intellij.execution.ui.ConsoleView;import com.intellij.notification.NotificationGroupManager;import com.intellij.notification.NotificationType;import com.intellij.openapi.components.AbstractProjectComponent;import com.intellij.openapi.components.ComponentManager;import com.intellij.openapi.fileEditor.FileEditorManager;import com.intellij.openapi.project.Project;import com.intellij.openapi.ui.popup.JBPopup;import com.intellij.openapi.ui.popup.PopupChooserBuilder;import com.intellij.openapi.vfs.VirtualFile;import com.intellij.openapi.wm.ToolWindow;import com.intellij.openapi.wm.ToolWindowManager;import com.intellij.openapi.wm.impl.IdeFrameImpl;import com.intellij.ui.content.Content;import org.intellij.ideaplugins.tabswitchx.component.Components;import org.jetbrains.annotations.Nullable;import javax.swing.*;import java.awt.*;import java.awt.event.KeyEvent;import java.awt.event.MouseListener;import java.awt.event.MouseWheelListener;import java.util.BitSet;import java.util.List;public class TabSwitchProjectComponent extends AbstractProjectComponent implements KeyEventDispatcher {  private final BitSet modifiers = new BitSet();  private final JList list;  private final PopupChooserBuilder builder;  private Project thisProject;  private JBPopup popup;  private int upTrigger;  private int dwTrigger;  private int windowHeight;  // public Dimension maxSize = new Dimension(1000, 1000);  // public Dimension minSize = new Dimension(150, 200);  private boolean isShifted = false;  public TabSwitchProjectComponent(Project project) {    super(project);    thisProject = project;    JLabel pathLabel = Components.newPathLabel();    this.list = Components.newList(project, pathLabel);    // this.list.setMaximumSize(maxSize);    this.builder = new PopupChooserBuilder(list);    this.builder      .setTitle("Open files")      .setCancelOnWindowDeactivation(false)      .setCancelOnClickOutside(true)      .setMovable(true)      .setUseDimensionServiceForXYLocation(true)      // .setMinSize(minSize)      .setAutoselectOnMouseMove(false)      .setSouthComponent(Components.newListFooter(pathLabel))      .setItemChoosenCallback(new Runnable() {        @Override        public void run() {          closeAndOpenSelectedFile();        }      });  }  public static TabSwitchProjectComponent getHandler(Project project) {    return project.getComponent(TabSwitchProjectComponent.class);  }  public Dimension recalculateSize(final int height) {    Dimension preferredSize = null;    if(popup != null) {      Dimension currentSize = popup.getSize();      if(currentSize != null) {        System.out.println("WINDOW HEIGHT: " + height + " ; SIZE: (" + currentSize.getWidth() + ", " + currentSize.getHeight() + ")");        final Project prj = this.thisProject;        // notifyInfo(prj, "WINDOW SIZE: (" + currentSize.getWidth() + ", " + currentSize.getHeight() + ")");        // int cellHeight = list.getFixedCellHeight();        Rectangle cellBounds = list.getCellBounds(0, 0);        double cHeight = cellBounds.getHeight();        int cellHeight = (int) cHeight;        // list.getScrollableTracksViewportHeight()        int cellCount = list.getModel().getSize();        int prefHeight = cellHeight * cellCount;		System.out.println("CELL HEIGHT: " + cellHeight + "\tTOTAL HEIGHT: " + prefHeight);        // int cellWidth = list.getWidth();        // int cellWidth = (int) currentSize.getWidth();        int cellWidth = list.getWidth();		int newWidth = cellWidth; // + 32 + 6;		  int goodSize = prefHeight + 53;		  int newHeight = currentSize.getHeight() < goodSize ? goodSize : prefHeight; //Integer.parseInt(currentSize.getHeight() + "");        // preferredSize = new Dimension(newWidth, prefHeight);        preferredSize = new Dimension(newWidth, newHeight);        System.out.println("PREFERRED SIZE: " + preferredSize);        JComponent contents = popup.getContent();		var j = contents.getComponent(0);        // System.out.println("COMPONENT: " + contents);        int visibleRows = list.getVisibleRowCount();        System.out.println("VISIBLE ROW COUNT: " + visibleRows);        int wantVisibleRows = visibleRows > 30 ? 30 : visibleRows < 1 ? 1 : cellCount;        list.setVisibleRowCount(wantVisibleRows);        System.out.println("WANTED ROWS COUNT: " + wantVisibleRows);        contents.setPreferredSize(preferredSize);        list.setPreferredSize(preferredSize);		list.setFixedCellWidth(-1);        popup.pack(true, true);      }    }    return preferredSize;  }  public void recalculatePosition() {    if(popup != null) {      JComponent component = popup.getContent();      Container parent = component != null ? component.getParent() : null;      Container grandparent = parent != null ? parent.getParent() : null;      Container grandparent2 = grandparent != null ? grandparent.getParent() : null;      Container popupDialog = grandparent2 != null ? grandparent2.getParent() : null;      IdeFrameImpl ideWindow = popupDialog != null ? (IdeFrameImpl) popupDialog.getParent() : null;      final String strComponent1 = component != null ? component.getClass().toString() : null;      final String strComponent2 = parent != null ? parent.getClass().toString() : null;      final String strComponent3 = grandparent != null ? grandparent.getClass().toString() : null;      final String strComponent4 = grandparent2 != null ? grandparent2.getClass().toString() : null;      final String strComponent5 = popupDialog != null ? popupDialog.getClass().toString() : null;      final String strComponent6 = ideWindow != null ? ideWindow.getClass().toString() : null;      System.out.println("JCOMPONENT IS:" + strComponent1 + "\n*** PARENT IS ***: " + strComponent2 + "\n*** GP IS ***: " + strComponent3 + "\nGP2 IS:" + strComponent4 + "\n*** DIALOG IS ***: " + strComponent5 + "\n*** IDEWindow IS ***: " + strComponent6);      if(ideWindow != null) {        Point winPoint = ideWindow.getLocation();        final int winX = winPoint != null ? winPoint.x : -1;        final int winY = winPoint != null ? winPoint.y : -1;        Dimension parentDimension = ideWindow.getSize();        Dimension dialogDimension = popupDialog.getSize();        final int componentX = (int) (winPoint.getX() + (parentDimension.getWidth() - dialogDimension.getWidth()) / 2);        // final int componentY = (int) (winPoint.getY() + (parentDimension.getHeight() - dialogDimension.getHeight()) / 2);        final int componentY = (int) (winPoint.getY() + 100);        System.out.println("\nWINPOINT: (" + winX + ", " + winY + ")\nRECALCULATED POSITION: (" + componentX + ", " + componentY + ")");        popup.setLocation(new Point(componentX, componentY));        popup.pack(false, true);      }    }  }  @Override  public boolean dispatchKeyEvent(KeyEvent event) {    System.out.println("dispatchKeyEvent: Key params: " + event.paramString());    // this.windowHeight =    if(popup != null && popup.isDisposed()) {      KeyboardFocusManager.getCurrentKeyboardFocusManager().removeKeyEventDispatcher(this);      return false;    } else if((event.getID() == KeyEvent.KEY_RELEASED)) {      int keyCode = event.getKeyCode();      if(keyCode == KeyEvent.VK_SHIFT) {        this.isShifted = false;      }      if(modifiers.get(keyCode)) {        if(keyCode == KeyEvent.VK_ESCAPE) {          close();        } else {          closeAndOpenSelectedFile();        }      }    } else if(event.getID() == KeyEvent.KEY_PRESSED) {      int keyCode = event.getKeyCode();      switch(keyCode) {        case KeyEvent.VK_UP:          moveUp();          break;        case KeyEvent.VK_DOWN:          moveDown();          break;        case KeyEvent.VK_TAB:          if(this.isShifted) {            moveUp();          } else {            moveDown();          }          break;        case KeyEvent.VK_ENTER:          closeAndOpenSelectedFile();          break;        case KeyEvent.VK_SHIFT:          this.isShifted = true;        case KeyEvent.VK_CONTROL:        case KeyEvent.VK_ALT:        case KeyEvent.VK_ALT_GRAPH:        case KeyEvent.VK_META:          break;        default:          moveOnTrigger(event);          break;      }    }    return true;  }  public void show(KeyEvent event, boolean moveUp, boolean moveOnShow, List<VirtualFile> files) {    setupTrigger(moveUp, event);    if(cannotShow(files)) {		return;	}    if(popup != null) {		popup.dispose();	}    prepareListWithFiles(files);    popup = builder.createPopup();    modifiers.set(KeyEvent.VK_CONTROL, event.isControlDown());    modifiers.set(KeyEvent.VK_META, event.isMetaDown());    modifiers.set(KeyEvent.VK_ALT, event.isAltDown());    modifiers.set(KeyEvent.VK_ALT_GRAPH, event.isAltGraphDown());    modifiers.set(KeyEvent.VK_SHIFT, event.isShiftDown());    KeyboardFocusManager.getCurrentKeyboardFocusManager().addKeyEventDispatcher(this);    popup.showCenteredInCurrentWindow(myProject);	popup.setUiVisible(false);    this.recalculateSize(this.windowHeight);    this.recalculatePosition();	popup.setUiVisible(true);    // ToolWindow toolWindow = ToolWindowManager.getInstance(project).getToolWindow(ID);    // ConsoleView consoleView = TextConsoleBuilderFactory.getInstance().createBuilder(project).getConsole();    // Content content = toolWindow.getContentManager().getFactory().createContent(consoleView.getComponent(), "A Console Foo Bar", true);    // toolWindow.getContentManager().addContent(content);    // popup.setLocation(new Point());    if(moveOnShow) {      move(0);    }  }  private void setupTrigger(boolean moveUp, KeyEvent event) {    if(moveUp) {      upTrigger = event.getKeyCode();    } else {      dwTrigger = event.getKeyCode();    }  }  private boolean cannotShow(List<VirtualFile> files) {    return files.isEmpty() || popup != null && popup.isVisible();  }  private void prepareListWithFiles(final List<VirtualFile> files) {    list.setModel(new AbstractListModel() {      @Override      public int getSize() {        return files.size();      }      @Override      public Object getElementAt(int index) {        return files.get(index);      }    });    int fileCount = files.size();    fileCount = fileCount > 30 ? 30 : fileCount;    // list.setVisibleRowCount(files.size());    System.out.println("Setting visible file count to: " + fileCount);    list.setVisibleRowCount(fileCount);    // int cellWidth = list.getFixedCellWidth();    // int cellHeight = list.getFixedCellHeight();    // int cellWidth = list.getFixedCellWidth();    // int cellHeight = list.getFixedCellHeight();    // int cellHeight = 32;    // int listHeight = cellHeight * fileCount;    // Dimension listDimension = new Dimension(cellWidth + 10, listHeight);    // System.out.println(String.format("NEW LIST SIZE (cellWidth: %d, cellHeight: %d, files: %d): ", cellWidth, cellHeight, fileCount) + listDimension);    // list.setPreferredSize(listDimension);  }  private void moveOnTrigger(KeyEvent event) {    if(event.getKeyCode() != upTrigger && event.getKeyCode() != dwTrigger) {      // close();    } else {      move((event.getKeyCode() == dwTrigger && event.isShiftDown()) || (event.getKeyCode() == upTrigger && !event.isShiftDown()));    }  }  private void move(boolean up) {    move(up ? -1 : 1);  }  private void moveUp() {    move(-1);  }  private void moveDown() {    move(1);  }  private void move(int offset) {    int size = list.getModel().getSize();    list.setSelectedIndex((list.getSelectedIndex() + size + offset) % size);    list.ensureIndexIsVisible(list.getSelectedIndex());  }  public void closeAndOpenSelectedFile() {    close();    openSelectedFile();  }  private void close() {    disposePopup();    removeMouseListeners();    KeyboardFocusManager.getCurrentKeyboardFocusManager().removeKeyEventDispatcher(this);  }  private void openSelectedFile() {    VirtualFile file = (VirtualFile) list.getSelectedValue();    if(file != null && file.isValid()) {      FileEditorManager.getInstance(myProject).openFile(file, true, true);    }  }  private void disposePopup() {    if(popup != null) {      popup.cancel();      popup.dispose();      popup = null;    }  }  /**   * Workaround for MouseListener leak added in PopupChooserBuilder.createPopup().   */  private void removeMouseListeners() {    for(MouseListener listener : list.getMouseListeners()) {      removeMouseListener(listener);    }    for(MouseWheelListener listener : list.getMouseWheelListeners()) {      removeMouseWheelListener(listener);    }  }  private void removeMouseListener(MouseListener listener) {    if(listener.getClass().getName().startsWith("com.intellij.openapi.ui.popup.PopupChooserBuilder")) {      list.removeMouseListener(listener);    }  }  private void removeMouseWheelListener(MouseWheelListener listener) {    if(listener.getClass().getName().startsWith("com.intellij.openapi.ui.popup.PopupChooserBuilder")) {      list.removeMouseWheelListener(listener);    }  }  public static void notifyError(@Nullable Project project, String content) {    NotificationGroupManager.getInstance()      .getNotificationGroup("TabSwitchX Group")      .createNotification(content, NotificationType.ERROR)      .notify(project);  }  public static void notifyInfo(@Nullable Project project, String content) {    NotificationGroupManager.getInstance()      .getNotificationGroup("TabSwitchX Group")      .createNotification(content, NotificationType.INFORMATION)      .notify(project);  }}